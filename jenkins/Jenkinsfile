pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
    ansiColor('xterm')
  }

  environment {
    AWS_ACCESS_KEY_ID     = credentials('aws-creds')
    AWS_SECRET_ACCESS_KEY = credentials('aws-creds')

    NEXUS_CREDS = credentials('nexus-creds')

    GITHUB_USERNAME   = "${env.GITHUB_USERNAME}"
    GITHUB_REPO       = "${env.GITHUB_REPO}"
    AWS_REGION        = "${env.AWS_REGION}"
    EKS_CLUSTER_NAME  = "${env.EKS_CLUSTER_NAME}"
    K8S_NAMESPACE     = "${env.K8S_NAMESPACE}"
    NEXUS_HOST        = "${env.NEXUS_HOST}"
    NEXUS_REGISTRY    = "${env.NEXUS_REGISTRY}"

    FRONTEND_TAG      = "${env.NEXUS_REGISTRY}:frontend-${env.BUILD_NUMBER}"
    BACKEND_TAG       = "${env.NEXUS_REGISTRY}:backend-${env.BUILD_NUMBER}"
    DB_TAG            = "${env.NEXUS_REGISTRY}:postgres-15"
  }

  triggers { githubPush() }

  stages {

    stage('Checkout') {
      steps {
        git branch: 'main', url: "https://github.com/${env.GITHUB_USERNAME}/${env.GITHUB_REPO}.git"
      }
    }

    stage('AWS EKS connect') {
      steps {
        sh 'set -e; aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"'
      }
    }

    stage('Create k8 namespace') {
      steps {
        sh 'set -e; kubectl create ns "$K8S_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -'
      }
    }

    stage('Docker login to Nexus') {
      steps {
        sh '''
          set -e
          echo "$NEXUS_CREDS_PSW" | docker login "$NEXUS_HOST" -u "$NEXUS_CREDS_USR" --password-stdin
        '''
      }
    }

    stage('Push DB image to Nexus (one-time)') {
      steps {
        sh '''
          set -e
          if docker pull "${DB_TAG}" >/dev/null 2>&1; then
            echo "DB image already exists in Nexus: ${DB_TAG}"
          else
            echo "Pushing DB image to Nexus for first time"
            docker pull postgres:15
            docker tag postgres:15 "${DB_TAG}"
            docker push "${DB_TAG}"
          fi
        '''
      }
    }

    stage('Build, tag & push frontend/backend') {
      steps {
        sh '''
          set -e
          docker build -t frontend:build ./app/frontend
          docker build -t backend:build ./app/backend

          docker tag frontend:build "${FRONTEND_TAG}"
          docker tag backend:build "${BACKEND_TAG}"

          docker tag frontend:build "$NEXUS_REGISTRY:frontend-latest"
          docker tag backend:build "$NEXUS_REGISTRY:backend-latest"

          docker push "${FRONTEND_TAG}"
          docker push "${BACKEND_TAG}"
          docker push "$NEXUS_REGISTRY:frontend-latest"
          docker push "$NEXUS_REGISTRY:backend-latest"
        '''
      }
    }

    stage('Create Secret in Kubernetes for Nexus') {
      steps {
        sh '''
          set -e
          kubectl -n "$K8S_NAMESPACE" create secret docker-registry nexus-secret \
            --docker-server="${NEXUS_REGISTRY}" \
            --docker-username="${NEXUS_CREDS_USR}" \
            --docker-password="${NEXUS_CREDS_PSW}" \
            --docker-email="a.e.n@gmail.com" \
            --dry-run=client -o yaml | kubectl apply -f -
        '''
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        sh '''
          set -e
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/db-configmap.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/db-service.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/backend-service.yaml
          kubectl -n "$K8S_NAMESPACE" apply -f k8s/frontend-service.yaml

          export FRONTEND_TAG BACKEND_TAG DB_TAG

          envsubst < k8s/db-deployment.yaml       | kubectl -n "$K8S_NAMESPACE" apply -f -
          envsubst < k8s/backend-deployment.yaml  | kubectl -n "$K8S_NAMESPACE" apply -f -
          envsubst < k8s/frontend-deployment.yaml | kubectl -n "$K8S_NAMESPACE" apply -f -

          kubectl -n "$K8S_NAMESPACE" rollout status deployment/db
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/backend
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/frontend
        '''
      }
    }
  }

  post {
    success {
      sh 'kubectl -n "$K8S_NAMESPACE" get svc frontend -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'
    }
    failure {
      echo 'Pipeline failed.'
    }
  }
}
